**进程间的通信**

进程间的通信有6种**:Bundle、文件共享、ContentProvider、AIDL、Messenger、Socket**

**3.1、Bundle篇** 

假设现在我们有两个activity,分别处于不同的进程，要给跳转到另一个进程的activity并传递数据，我们可以通过Bundle的put/get存取数据，然后通过Intent.put/getExtras来。存取bundle数据。

给不同进程发送数据代码:

![image](https://upload-images.jianshu.io/upload_images/7730759-8a85d5b7c59ac213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

接收数据代码:

![image](https://upload-images.jianshu.io/upload_images/7730759-b51c17ba1576d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**3.2、共享文件篇**

共享文件就是通过两个进程共读/写同一个文件的内容。

第一个activity在跳转到其他进程之后，做了一个写入数据到文件的操作

![image](https://upload-images.jianshu.io/upload_images/7730759-1fc2019ffe84044a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

另一个进程activity则读取这个文件的数据：

![image](https://upload-images.jianshu.io/upload_images/7730759-f7ad5534e1321453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**3.3、ContentProvider**

以前我也被contentProvider和contentResolver这两个东西有点糊里糊涂。

因为这两个该有的方法都一样，getType、insert、update、delete、query的功能和实现上都一模一样，那为什么要定义两个不同的抽象类呢?其实 它们是有分工的，如果你想你的数据被别人访问，那你就要继承ContentProvider并根据自己要提供的特定数据重写里面的getType、query、insert、update、dalete，记得要在manifest中注册。如果你的项目有继承重写ContentProdier，那么在你context.getContentResolver()得到的contentResolver就用你重写的类的方法，如果没有就用系统提供的ContentProvider提供的方法。

实质上ContentProvider还是通过文件共享的读取来实现数据的跨进程共享。ContentProvider的底层也是由binder实现，只有onCreat是运行在UI线程中，其他方法都是在Binder的线程池中(耗时操作)。

一个类继承了ContentProvdier抽象类代码:

![image](https://upload-images.jianshu.io/upload_images/7730759-0e61bd978f767d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**3.4、AIDL**

还记得我们写service的时候，有一种bindService绑定可以跟随activity的关闭而关闭，但是在继承service页面的时候，我们要在里面实现一个内部类并继承BInder，并在里面写我们想要操作的方法，然后通过onBind方法传给启动的activity。

Aldl的文件其实也是Ibinder,不过是把它变成接口，并把我们的要操作的方法写成抽象方法在实例的时候为它们重写。

service通过AIDL实现代码Binder。

![image](https://upload-images.jianshu.io/upload_images/7730759-c16c04ed570dbed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**3.4、Messenger**

**3.5、Socket** 

**怎样开启多进程** 

android开启多进程很简单，只要在manifest文件给activity、service的process属性设置进程名就可以了。其中有两种方式设置进程名：一种是你直接自定义整个进程的名字，一种是:单词，意思是"包名:单词"是它的进程名。

![image](https://upload-images.jianshu.io/upload_images/7730759-874735b0131a1805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

实现多进程

**2.序列化接口**

java的Serializable和安卓自己的Parcelable，一般会用在我们的javaBean类上。Parcelable的效率更高，原因是Serializable要通过大量的IO操作和反射，要新建很多临时变量。

实现Serializable的方式很简单，类直接实现Serializable的接口就行了，不过它里面的调用的类也要实现Serializable，不然会报错。

实现Parcelable的方式稍微麻烦些，类要实现Parcelable的接口，并实现接口里面的两个抽象类describeContents、writeToParcel，其中describeContents总是返回0，writeToParcel是将对象写入序列dest中。还要在类中实现一个非空的静态实现了[Parcelable.Creator](https://developer.android.google.cn/reference/android/os/Parcelable.Creator.html)接口的CREATOR，和一个带parcel参数的构造方法，用于反序列化。

实现抽象方法用于序列化

![image](https://upload-images.jianshu.io/upload_images/7730759-be9fab760ca91c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

序列化代码

自写两方法用于反序列化：

![image](https://upload-images.jianshu.io/upload_images/7730759-818c7c9936a44626.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

反序列化代码
